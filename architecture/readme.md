# Документация модуля "Реестр гражда" проекта "Мэта-Беларусь"
Дисклеймер тут разрозненно.
[Освноная схема со всем скоупом тут](./crdesign.drawio)

## Общее описание
Делаем систему со множеством способов верификации - один (через знакомых) будет основной.
Способы можно будет «врубать» в любом порядке. Сторонние сервисы смогут как добавлять «теги» верификации свои, так и запрашивать определенные теги для того чтобы аккаунт мог этими сервисами пользоваться.
В том числе обсуждаем механизм периодической реверификации аккаунтов как дополнительный способ борьбы с дублями.

Использование паспортов исключили - в нашем случае не надежно и никто не будет свои паспорта засовывать в непонятную систему. Более того беларуский паспорт без 5 минут менее легальная бумажка чем запись в нашем ещё не существующем реестре.


Принципы от которых мы сейчас отталкиваемся:
1. ввиду правового дефолта любые документы выпущенные на территории РБ на данный момент не имеют долгосрочной юридической силы и могут быть использованы злоумышленниками для компрометирование системы (например МВД может в любой момент наштамповать паспортов для мертвых душ любого KYC или анулировать ваш паспорт)
2. мы исходим из того что когда победим, такая децентрализованная система которая никому не доверят будет иметь смысл, просто хотябы что бы второй Лукашенко был невозможен
3. отключите пожалуйста все привычки в вопросах документов и верификации - они будут мешать думать ввиду первых двух предпосылок
4. Это очень маленький и „тонкий” модуль который является децентрализованным хабом без центрального владельца
5. Т.к. у нас мало ресурсов все функции в ресстре редуцированы до авторизации людей и сервисов
6. К реестру могут быть подключены любые сервисы которые выбирут пользователи \ граждане — в том числе и те самые реестры про которые вы говорите. И репликация данных из них уже больше даже головняк тех кто будет их подключать.
7. Подключение и отключение к реестру как системе авторизации какого либо сервиса - результат волеизъявления граждан \ пользователей.

В реестр из коробки будет зашита функция регистрации через приглашения и кросс подтверждения, скорее как способ бутстрапа и как возможность работать автономно в случае какого либо колапса внешних систем или же потери к ним доверия со стороны граждан.

## Базовые требования к алгоритмам (english)
1. “6 handshakes” is a real thing: 1st level - 150 requests, 2 has 50 requests, 3 has 15 requests, 4 has 5 requests, 5 has 5 requests in 2 months, then +1 request every 2 months (max 5)
2. People can be asked to set their primary geo locations (e.g. registration). To mark the place where they can be confirmaed by neighbours.
3. 1 level requests can be configured the following way
    1. 1 level - 3 confirmation points, reconfirmation off
    2. 2 level - 2? confirmation points, reconfirmation off
    3. 3 level - 2 confirmation points, reconfirmation off
    4. 4 level - 2 confirmation, reconfirmation on
    5. 5 level - 1 confirmation, reconfirmation on
    6. 6 level (and any autogenerated request) - 0 confirmation, reconfirmation on 
4. Confirmation requires providing of private data
    1. Security implications in the yabat’ka context (can be turned into adoption mechanics) 
        1. Yebat’ka can be motivated to invite his or her real people 
    2. Providing of private data is a private data protection condition for some countries (GDPR)
        1. Private data can be deleted later
5. Request of non belarusian citizens should be marked (required to become validators, to support diaspors)
    1. Non Belarusian citizen can’t invite people
    2. Non Belarusian citizens can invite Non-belarusian citizens only
    3. Non Belarusian can’t vote for services and participate in such voting
    4. Non Belarusian can’t confirm Belarusians 
    5. Non Belarusian has nationality marker, that define their scope of requests and confirmations
    6. It’s a crime - to invite non Belarusian as Belarusian

## Система подтверждения аккаунтов
1. Аккаунт создается и становится активным до высылки запроса на подтверждение
2. Подтверждений может быть получено больше 1го
   1. 2|1? подтверждение - чтобы обозначать доверие \ недоверие сервису
   2. 1|2? подтверждения - нужно чтобы подтверждать других людей
   3. 3 подтверждения - нужно чтобы высылать приглашения
   4. После первого подтверждения человек получает специальный бедж KYC со счетчиком подтверждений
   5. Другие сервисы могут требовать больше подтверждений
3. Запрос на подтверждение высылается по гео по месту регистрации
4. Получивший запрос на подтвреждение должен подтвердить, что тут живёт такой человек
5. Раз в два месяца высылается новый запрос на подтверждение
6. Сторонний сервис с соответствующими правами может выключить на аккаунте необходимость повторных подтверждений
7. Пригласивший не может подтверждать пришлашенного. Подтвердивший не может быть подтвержден подтвержденным.


## Текущие развитие системы приглашений
1. Создаём аккаунт с 100 супер приглашениями ✅ и 1000 стэйка ❓. 
2. У аккаунта так же есть полный комплект приглашений:
- 150 приглашений tire 0 ✅
- 100 приглашений tire 1  ✅
- 50 приглашений tire 2 ✅
- 15 приглашений tire 3 ✅
- 5 приглашений tire 4 ✅
- 0 приглашений  tire 4 ✅
2. Супер приглашения позволяют создавать аккаунты с полным комплектом приглашений. ✅
3. Каждое следующее приглашение создаёт аккаунт без одного верхнего таера комплекта приглашений предыдущего таера. ✅
4. Мы дадим возможность приглашать аккаунты типа служебный ⚠️

### Создание Supper Identity:
1. Создаем аккаунт c токенами ✅
2. Создаём Identity для созданного аккаунта ✅
3. Не забываем подписать транзакцию приватным ключом ✅

### Создаем Service Identity:
1. Создаем service приглашение ✅
1.1. Проверяем что у создающего аккаунта есть супер приглашения ✅
1.2 Тратим супер приглашение ✅
1.3. Создаем пару публичный \ приватный ключ ✅
1.4. → Вяжем приглашение к создающему аккаунту при принятии приглашения ✅
1.5. Собираем пару id приглашения+приватный ключ от него ✅

2. Принимаем приглашение на service identity ✅
2.1. Генерируем публичный ключ из приватного ключа и проверяем наличие приглашения с указанным ID и приватным ключом ✅
2.2. Проверяем что у приглашения еще нет IdentityID ✅
2.3. Проверяем что сервис хочет зарегаться с уникальным Alias ❌
2.4. Создаем аккаунт (мнемоники, приватный ключ, публичный ключ, адрес) ✅
2.5. Зачисляем токены на аккаунт (у сервис аккаунта это 1 денюжка наверное) ⚠️
2.6. Создаем Service Identity и вяжем её к аккаунту ✅
2.7. Создаем запись в паспорте об алиасе сервиса


## Signatures and Authentication
Extenral services can request infromation to be signed by a citizen. The same approach should be used for authentication and authrization in external services.
### Principles

1. A service provides some public session id that is linked to a user alongside some secret session id — secret id is stored encrypted with user's public, that allows to prove ownership of the signature between specific user and the service, to avoid duplication of a public session id
2. The user creates a signature record with this data and gets its id — it's required as a proof that the user that got data has assumed identity
3. The user provides signature ID to the service
4. The service checks that provided ID is really linked to the specific user identity in the blockchain
5. To store and lookup such signature in the db we use additional mapping table
    1. A map that maps a user to all his or her signatures 

### Algorithms

1. Auth Login
    1. User sends to service his or her identity id
    2. Service creates the following session info: service identity id, user identity id
    3. Service also writes the secret key encrypted with user's public key
    4. User changes auth status from open to signed
        1. User adds a record to the identity → signature map
2. Session Authentication
    1. User sends signature id, identity id, and decrypted private session key to the service
    2. Service checks if the signature has signed status
    3. Service checks if availability is still fresh
        1. If availability is no more than hour stale, user and service can invisibly update the signature ?
            1. Update signature
            2. Inform user about update
            3. User resends request to the service with updated session key
        2. Otherwise the service should return that the session is expired 